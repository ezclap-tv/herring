(*
Written with extended EBNF (extended extended Backus-Naur form).

Extensions:
- Syntax common in regular expressions
  - `item?` means zero or one occurence of `item`
  - `item*` means zero or more occurrences of `item`
  - `item+` means one or more occurrences of `item`
  - `item{N}` means exactly N occurrences of `item`
  - `item{N,}` means N or more occurrences of `item`
  - `item{N,M}` means between `N` and `M` occurrences of `item`
  - `a | b` means either `a` or `b` may appear in this position
  - `(a b c)` defines a group which may contain one or more items,
                and any of the above symbols apply to the group as a whole
- Precedence reset operator `$`
  - It has no effect on the items, but has the highest precedence.
    It is used as a replacement for grouping:
      a $ b | c
    is equivalent to
      a (b | c)
    instead of
      (a b) | c
- Terminals with substitution
  - repeat{`item} = `item*

The grammar may also contain regex terminals, written in the form `regex{"<regex>"}`.
For example: `regex{"[a-bA-B_][a-bA-B_0-9]*"}` describes an ident which consists
of alphanumeric characters or underscores, except at the start, where digits may
not appear.

Terminals such as `"test"` are case-sensitive.

This grammar does not describe a whitespace-sensitive language, which means that
any amount of whitespace is allowed to exist between any two elements, and is always
ignored, unless explicitly notated as `NEWLINE` for `\n` or `WHITESPACE` for `\s`.

*)

module = body:top_level* ;

top_level =
  | "pub"? decl_fn
  | "pub"? decl_type ";"
  | "pub"? decl_class
  | "pub"? decl_trait
  | import ";"
  | stmt
  ;

block = "{" body:stmt* "}" ;

stmt =
  | stmt_loop
  (* semicolon after expr is only required if previous token != `}` *)
  | stmt_let ";"
  | stmt_expr ";"
  ;

  import = "use" import_path ;

    import_path =
      | ident ("as" ident)?
      | ident ("." import_path)? 
      | "{" list{import_path} "}"
      ;

  stmt_let =
    "let"
    name:ident
    (":" type:type)?
    "=" value:expr ;

  decl_fn =
    "fn" name:ident
    type_params:type_params_list?
    params:params_list
    ("->" return:type)?
    ("where" bounds:list{bound})?
    (block | ";")
    ;

  decl_type =
    "type" name:ident
    type_params:type_params_list?
    ("where" bounds:list{bound})?
    "=" type
    ;

  decl_class =
    "class" name:ident
    type_params:type_params_list?
    ("where" bounds:list{bound})?
    ("{" body:class_member* "}" | ";")?
    ;

    class_member =
      | class_field ";"
      | decl_fn
      | decl_type ";"
      | decl_impl
      ;

    class_field = name:ident ":" type:type ;

  decl_trait =
    "trait" name:ident
    type_params:type_params_list?
    "{" body:trait_member* "}"
    ;

  decl_impl =
    | "impl" type_params:type_params_list? trait:type "for" type
    | "impl" type_params:type_params_list? type:type 
    $ ("{" body:trait_member* "}")?
    ;

    trait_member =
      | decl_fn
      | decl_type ";"
      ;

  stmt_loop =
    | loop_for
    | loop_while
    | loop_inf
    ;

    loop_for = "for" item:ident "in" iter:expr block ;
    loop_while = "while" cond:expr block ;
    loop_inf = "loop" block ;

  stmt_expr = expr ;


expr = expr_assign ;
  expr_assign =
    | assign_target ("=" | "+=" | "-=" | "/=" | "*=" | "%=" | "**=" | "??=") expr
    | expr_range
    ;
    assign_target =
      | ident
      | expr_postfix field
      | expr_postfix index
      ;
  expr_range = expr_binary (".." | "..=") expr_binary ;
  expr_binary = expr_opt ;
    expr_opt = expr_or (("??") expr_or)* ;
    expr_or = expr_and (("||") expr_and)* ;
    expr_and = expr_eq (("&&") expr_eq)* ;
    expr_eq = expr_comp (("==" | "!=") expr_comp)* ;
    expr_comp = expr_add ((">"  | ">=" | "<" | "<=") expr_add)* ;
    expr_add = expr_mul (("-" | "+") expr_mul)* ;
    expr_mul = expr_pow (("/" | "*" | "%") expr_pow)* ;
    expr_pow = expr_unary (("**") expr_unary)* ;
  expr_unary = expr_prefix | expr_postfix ;
    expr_prefix = ("-" | "!") expr_unary ;
    expr_postfix = expr_primary (expr_call | expr_field | expr_index | expr_cast)* ;
      (* "?" means optional call, field access, or index *)
      expr_call = "?"? "(" args:list{expr}? ")" ;
      expr_field = "?"? "." name:ident ;
      expr_index = "?"? "[" key:expr "]" ;
      expr_cast = "." "(" ty:type ")" ;
  expr_primary =
    | expr_null
    | expr_number
    | expr_bool
    | expr_string
    | expr_array
    | expr_tuple
    | expr_init
    | expr_var
    | expr_ctrl
    | expr_block
    | expr_if
    | expr_try
    | expr_spawn
    | expr_lambda
    | expr_group
    ;
  expr_null = "null" ;
  expr_bool = "true" | "false" ;
  expr_number = (int | float) ;
    int = (int_bin | int_dec | int_hex) ;
    int_bin = regex{"0b[01]([01_]*[01])?"} ;
    int_dec = regex{"[0-9]([0-9_]*[0-9])?"} ;
    int_hex = regex{"0x[0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?"} ;
    float = "inf" | regex{"[0-9]+(\.[0-9]*)?([Ee][+-]?[0-9]+)?"} ;
  expr_string = '"' UTF8* '"' ;
  expr_array = "[" (list{expr} | expr ";" expr) "]" ;
  expr_tuple = "(" ((expr ",")? | (expr ",")+ expr?) ")" ;
  expr_init = type "{" fields:list{ident ":" expr} "}" ;
  expr_var = ident ;
  expr_ctrl =
    | "return" value:expr?
    | "break"
    | "continue"
    | "throw" value:expr?
    ;
  expr_block = "do" block ;
  expr_if =
    "if" cond:expr if_body
    ("else" "if" cond:expr if_body)*
    ("else" if_body)?
    ;
    if_body = 
      | expr_ctrl
      | stmt_loop
      | block
      ;
  expr_try =
    | "try" body:expr branches:try_branch_list
    | "try" body:block "catch" branches:try_branch_list
    ;
    try_branch_list = "{" list{try_branch, ";"} "}" ;
      try_branch = type "=>" stmt ;
  expr_spawn =
    | "spawn" body:block
    | "spawn" fn:expr args:call
    ;
  expr_lambda =
    "\\" $
    | param:ident
    | "(" params:list{ident} ")"
    $ block
    ;
  expr_group = "(" expr ")" ;


(* TODO *)
type = type_optional ;
  type_optional = type_postfix "?" ;
  type_postfix = type_primary (type_field | type_inst)* ;
    type_field = "." ident
    type_inst = "[" list{type} "]" ;
  type_primary =
    | type_var
    | type_fn
    | type_array
    | type_tuple
    | type_group
    ;
  type_var = ident ;
  type_fn =
    "fn"
    "(" list{type} ")"
    ("->" type)?
    ;
  type_array = "[" type "]" ;
  type_tuple = "(" ((type ",")? | (type ",")+ type?) ")" ;
  type_group = "(" type ")" ;


bound = ty:type ":" constraint:constraint ;
  constraint = type ("+" type)* ;

type_params_list = "[" list{type_param} "]" ;
  type_param = name:ident ("=" default:type)? ;

params_list = "(" list{param} ")" ;
  param = name:ident (":" type)? ("=" expr)? ;

ident = regex{"[a-bA-B_][a-bA-B_0-9]*"} ;

path = ident ("." ident)* ;

list{`item, `sep = ","} = (`item (`sep `item `sep?)*)? ;
