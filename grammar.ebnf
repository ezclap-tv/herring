(*
Written with regex-like extensions and interpolations on top of EBNF.

Regex-like extensions:
- `element?` means zero or one occurence of `element`
- `element*` means zero or more occurrences of `element`
- `element+` means one or more occurrences of `element`
- `element{N}` means exactly N occurrences of `element`
- `element{N,}` means N or more occurrences of `element`
- `element{N,M}` means between `N` and `M` occurrences of `element`
- `a | b` means either `a` or `b` may appear in this position
- `( a b c )` defines a group which may contain one or more elements,
              and any of the above symbols apply to the group as a whole

Terminals such as `"test"` are case-sensitive.

This grammar does not describe a whitespace-sensitive language, which means that
any amount of whitespace is allowed to exist between any two elements, and is always ignored,
unless explicitly notated as `NEWLINE` for `\n` or `WHITESPACE` for `\s`.

This grammar does not attempt to describe the semantics of the language,
such as when certain statements or expressions can appear.
It only describes the syntax at a "surface" level.

TODO: type expressions, expressions, if, match, etc.
TODO: range

*)

program = top_level_stmt* EOF ;

top_level_stmt =
  | import
  | export
  | stmt
  ;


import = "import" import_list ";"? ;
import_list = import_block | import_fragment ;
import_block = "{" import_fragment ( "," import_fragment ","? )* "}" ;
import_fragment = import_alias | import_nested ;
import_alias = IDENTIFIER "as" IDENTIFIER ;
import_nested = IDENTIFIER ( "." import_list )? ;


export = "export" export_block ";"? ;
export_block = "{" export_alias ( "," export_alias ","? )* "}" ;
export_alias = IDENTIFIER "as" IDENTIFIER ;


stmt =
  ( | var_decl
    | block_stmt
    | loop_stmt
    | ctrl_stmt
    | fn_stmt
    | class_stmt
    | enum_stmt
    | with_stmt
    | type_stmt
    | expr_stmt
    | 
  ) ";"? ;


var_decl =
  | IDENTIFIER ":=" expression
  | IDENTIFIER ":" type_expr ( "=" expression )?
  ;


block_stmt = "{" stmt* "}" ;


loop_stmt =
  | for_loop_stmt
  | while_loop_stmt
  | inf_loop_stmt
  ;
for_loop_stmt = label? "for" IDENTIFIER "in" expr loop_body ;
while_loop_stmt = label? "while" expr loop_body ;
inf_loop_stmt = label? "loop" loop_body ;
loop_body = block_stmt ;

# no whitespace between the quote and identifier is allowed
# no idea how to encode this in the grammar
label = "'" IDENTIFIER;

ctrl_stmt =
  | return_stmt
  | throw_stmt
  | break_stmt
  | continue_stmt
  ;
return_stmt = "return" expr? ;
throw_stmt = "throw" expr ;
break_stmt = "break" label? ;
continue_stmt = "continue" label? ;


fn_stmt = "export"? fn ;
fn = "fn" IDENTIFIER type_param_list? param_list fn_attributes? block_stmt ;
fn_attributes = fn_return_type? fn_throw_type? constraint? ;
fn_return_type = "->" type_expr ;
fn_throw_type = "throws" type_expr ;


class_stmt = "export"? class ;
class = "class" IDENTIFIER type_param_list? constraint? class_member_list ;
class_member_list = "{" class_member ( any_separator class_member any_separator )* "}" ;
class_member =
  | class_member_field
  | class_member_method
  | class_member_type
  ;
class_member_field = IDENTIFIER ( ":" type_expr )? ( "=" expr )? ;
class_member_method = fn_stmt ;
class_member_type = type_stmt ;


enum_stmt = "export"? enum ;
enum = "enum" IDENTIFIER type_param_list? constraint? enum_variant_list ;
enum_variant_list = "{" enum_variant ( any_separator enum_variant any_separator )* "}" ;
enum_variant =
  | enum_unit_variant
  | enum_tuple_variant
  | enum_struct_variant
  ;
enum_unit_variant = IDENTIFIER ;
enum_tuple_variant = IDENTIFIER tuple_type_expr ;
enum_struct_variant = IDENTIFIER struct_type_expr ;


type_param_list = "[" ( type_param ( "," type_param ","? )* )? "]" ;
type_param = IDENTIFIER ( ":" type_expr )? ( "=" type_expr ) ;
param_list = "(" ( param ( "," param ","? )* )? ")" ;
param = IDENTIFIER ( ":" type_expr )? ( "=" expr )? ;

constraint = "where" constraint_bound_list ;
constraint_bound_list = constraint_bound ( "," constraint_bound ","? )* ;
constraint_bound = IDENTIFIER ":" type_expr ;


with_stmt = "with" ( IDENTIFIER ":=" )? expr block_stmt ;


type_stmt = "export"? "type" IDENTIFIER "=" type_expr ;

(*
TODO: type expressions
type operators:
- intersection `&`
- union `|`
- field/associated type access `.`
*)
type_expr =
  ;


expr_stmt = expr ;

expr =
  | do_block_expr
  | if_expr
  | match_expr
  | fn_expr
  | class_expr
  | enum_expr
  | spawn_expr
  | assignment
  ;


do_block_expr = "do" block_stmt ;


if_expr = "if" condition if_expr_body ( "else" ( if_expr | block ) )? ;
if_expr_body =
  | block_stmt
  | loop_stmt
  | ctrl_stmt
  ;

match_expr = "match" expr "{" match_case_list "}";
match_case_list = match_case ( any_separator match_case any_separator? )* ;
match_case = pattern case_guard? "->" stmt ;

case_guard = "if" expr ;

(* TODO: pattern *)
pattern = "error"? pattern_inner ;
pattern_inner =
  | any_pattern
  | ignore_pattern
  | bool_pattern
  | null_pattern
  | integer_pattern
  | range_pattern
  | string_pattern
  | array_pattern
  | tuple_pattern
  | struct_pattern
  | enum_pattern
  ;

pattern_with_rest = rest_pattern | pattern_inner ;
rest_pattern = ".." pattern_binding? ;

any_pattern = IDENTIFIER ;
ignore_pattern = "_" ;
bool_pattern = ( "true" | "false" ) pattern_binding? ;
null_pattern = "null" pattern_binding? ;
integer_pattern = integer pattern_binding? ;
range_pattern =
  ( | integer ".." integer
    | integer ".."
    | ".." integer
  ) pattern_binding? ;
string_pattern =
  | quote text quote
  | apos text apos
  ;
array_pattern = "[" rest_pattern ( "," rest_pattern ","? )* "]" ;
tuple_pattern = "(" rest_pattern ( "," rest_pattern ","? )* ")" ;
struct_pattern = "{" struct_pattern_item ( "," struct_pattern_item ","? )* "}" ;
struct_pattern_item =
  | IDENTIFIER
  | IDENTIFIER ":" pattern
  | rest_pattern
  ;
enum_pattern = IDENTIFIER? "." IDENTIFIER ( tuple_pattern | struct_pattern )? ;
pattern_binding = "as" IDENTIFIER ;


(*
these exist only because they have different scoping rules
specifically, the name is not declared in the enclosing scope,
only in its own body
*)
fn_expr = fn ;
class_expr = class ;
enum_expr = enum ;


spawn_expr = "spawn" spawn_expr_body ;
spawn_expr_body =
  | block_stmt
  | call
  ;


assignment = 
  | assignment_target ( assignment_op expression )?
  | pipeline 
  ;
assignment_op = "=" | "+=" | "-=" | "/=" | "*=" | "%=" | "**=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "||=" | "&&=" | "??=" ;
assignment_target =
  | IDENTIFIER
  | call field_access
  | call item_access
  ;


pipeline = logic_or ( "|>" logic_or )* ;
logic_or = logic_and ( "||" logic_and )* ;
logic_and = bitwise_or ( "&&" bitwise_or )* ;
bitwise_or = bitwise_xor ( "|" bitwise_xor )* ;
bitwise_xor = bitwise_and ( "^" bitwise_and )* ;
bitwise_and = equality ( "&" equality )* ;
equality = comparison ( ( "==" | "!=" ) comparison )* ;
comparison = bitshift ( ( ">" | ">=" | "<" | "<=" ) bitshift )* ;
bitshift = addition ( ( "<<" | ">>" ) addition )* ;
addition = multiplication ( ( "-" | "+" ) multiplication )* ;
multiplication = exponentiation ( ("/" | "*" | "%" ) exponentiation )* ;
exponentiation = unary ( "**" exponentiation )* ;

unary = prefix | inc | dec | postfix ;
prefix = ( "!" | "-" | "~" | "try" | "try!" ) unary ;
inc = "++" assignment_target | assignment_target "++" ;
dec = "--" assignment_target | assignment_target "--" ;

postfix = primary ( call | field_access | item_access | try )* ;
call = "(" args? ")" ;
field_access = ( "." | "?." ) IDENTIFIER ;
item_access = "[" expression "]" ;
try = "." ( "try" | "try!" ) ;

primary =
  | bool
  | null
  | number
  | string
  | array
  | struct
  | lambda
  | tuple
  | grouping
  ;

bool = "true" | "false" ;

null = "null" ;

(*
valid numbers:
  0b0000_0000
  -149120421940
  0xb00ba
  -inf
  1.0e5
  3.14e-5
  1f
  1i
also with prefixes:
  10ms
  5.1s
integers have higher precedence than floats
*)
number = ( integer | float ) IDENTIFIER? ;
integer = ( base_2 | base_10 | base_16 ) suffix? ;
integer_base_2 = regex{0b[01]([01_]*[01])?} ;
integer_base_10 = regex{[0-9]([0-9_]*[0-9])?} ;
integer_base_16 = regex{0x[0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?} ;
float =
  | "inf"
  | ( regex{(([0-9]+)(\.[0-9]*)?)([Ee][+-]?[0-9]+)?} suffix? )
  ;

(* strings also support escapes such as \n \t \x2800 etc.*)
string = 
  | ( quote string_fragment* quote )
  | ( apos string_fragment* apos )
  ;
string_fragment =
  | "{" expr "}"
  | "\{" text "}"
  | text
  ;
text = UTF8* ;
apos = "'" ;
quote = '"' ;

array = "[" array_item_list "]" ;
array_item_list = array_item ( "," array_item ","? )* ;
array_item = spread ;

struct = "{" struct_fields "}" ;
struct_field_list = struct_field ( "," struct_field ","? )* ;
struct_field =
  | IDENTIFIER
  | IDENTIFIER ":" expr
  | "[" expr "]" ":" expr
  | spread
  ;

lambda = "\\" lambda_param_list block_stmt ;
lambda_param_list = IDENTIFIER | param_list ;

tuple = "(" expr "," ( expr "," )* ")" ;
grouping = "(" expr ")" ;

spread = "..."? expr ;

any_separator = "," | ";" | NEWLINE ;