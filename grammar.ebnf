(*
Written with regex-like extensions and interpolations on top of EBNF.

Regex-like extensions:
- `element?` means zero or one occurence of `element`
- `element*` means zero or more occurrences of `element`
- `element+` means one or more occurrences of `element`
- `element{N}` means exactly N occurrences of `element`
- `element{N,}` means N or more occurrences of `element`
- `element{N,M}` means between `N` and `M` occurrences of `element`
- `a | b` means either `a` or `b` may appear in this position
- `( a b c )` defines a group which may contain one or more elements,
              and any of the above symbols apply to the group as a whole

The grammar may also contain regex terminals, written in the form `regex{"<regex>"}`.
For example: `regex{"[a-bA-B_][a-bA-B_0-9]*"}` describes an identifier which consists
of alphanumeric characters or underscores, except at the start, where digits may
not appear.

Terminals such as `"test"` are case-sensitive.

This grammar does not describe a whitespace-sensitive language, which means that
any amount of whitespace is allowed to exist between any two elements, and is always
ignored, unless explicitly notated as `NEWLINE` for `\n` or `WHITESPACE` for `\s`.

TODO: comments

*)

program = top_level_stmt* EOF ;

top_level_stmt =
  | import
  | export
  | stmt
  ;

import = "import" import_list ";"? ;
import_list = import_block | import_fragment ;
import_block = "{" import_fragment ( "," import_fragment ","? )* "}" ;
import_fragment = import_alias | import_nested ;
import_alias = IDENTIFIER "as" IDENTIFIER ;
import_nested = IDENTIFIER ( "." import_list )? ;

export = "export" export_item ";"? ;
export_item =
  | export_block
  | fn_stmt
  | class_stmt
  | enum_stmt
  | type_stmt
  ;
export_block = "{" export_alias ( "," export_alias ","? )* "}" ;
export_alias = IDENTIFIER "as" IDENTIFIER ;

stmt =
  ( | var_decl
    | block_stmt
    | loop_stmt
    | ctrl_stmt
    | with_stmt
    | fn_stmt
    | class_stmt
    | enum_stmt
    | type_stmt
    | expr_stmt
    | 
  ) ";"? ;

var_decl =
  | IDENTIFIER ":=" expression
  | IDENTIFIER ":" type_expr ( "=" expression )?
  ;

block_stmt = "{" stmt* "}" ;

loop_stmt =
  | for_loop_stmt
  | while_loop_stmt
  | inf_loop_stmt
  ;
for_loop_stmt = label? "for" IDENTIFIER "in" expr loop_body ;
while_loop_stmt = label? "while" expr loop_body ;
inf_loop_stmt = label? "loop" loop_body ;
loop_body = block_stmt ;

label = regex{"'[a-bA-B_][a-bA-B_0-9]*"};

ctrl_stmt =
  | return_stmt
  | throw_stmt
  | break_stmt
  | continue_stmt
  ;
return_stmt = "return" expr? ;
throw_stmt = "throw" expr ;
break_stmt = "break" label? ;
continue_stmt = "continue" label? ;

with_stmt = "with" with_decl ( ";" with_decl ";"? )* block_stmt ;
with_decl = ( IDENTIFIER ":=" )? expr ;

fn_stmt = fn ;
fn = "fn" IDENTIFIER type_param_list? param_list fn_attributes? block_stmt ;
fn_attributes = fn_returns? fn_throws? constraint? ;
fn_returns = "->" type_expr ;
fn_throws = "throws" IDENTIFIER ( "," IDENTIFIER ","? )* ;

class_stmt = class ;
class = "class" IDENTIFIER type_param_list? constraint? "{" class_member_list? "}" ;
class_member_list = class_member ( separator class_member separator? )* ;
class_member =
  | class_member_field
  | class_member_method
  | class_member_type
  ;
class_member_field = IDENTIFIER ( ":" type_expr )? ( "=" expr )? ;
class_member_method = fn_stmt ;
class_member_type = type_stmt ;

enum_stmt = enum ;
enum = "enum" IDENTIFIER type_param_list? constraint? "{" enum_variant_list? class_member_list? "}" ;
enum_variant_list =
  "|"? enum_variant ( ( "|" | "," ) enum_variant ( "|" | "," )? )* ;
enum_variant = IDENTIFIER enum_variant_inner?;
enum_variant_inner =
  | "(" type_expr ( "," type_expr ","? )* ")"
  | record_type
  ;

type_stmt = "type" IDENTIFIER type_param_list? constraint? type_stmt_init ;
type_stmt_init =
  | record_type
  | "=" type_expr
  ;

type_expr = type_intersection ;

(* intersections are only valid on types that reduce to record types *)
type_intersection = nullable_type ( "+" nullable_type )* ;

nullable_type = primary_type "?" ;

primary_type =
  | fn_type
  | array_type
  | record_type
  | tuple_type
  | enum_type
  | primitive_type
  | grouping_type
  ;

fn_type = "fn" "(" fn_type_param_list? ")" fn_returns? fn_throws? ;
fn_type_param_list = type_expr ( "," type_expr ","? )* ;

array_type = "[" type_expr "]" ;

record_type = "{" record_type_pair ( "," record_type_pair ","? )* "}" ;
record_type_pair = IDENTIFIER ":" type_expr ;

tuple_type = "(" ( ( type_expr "," )+ type_expr? )? ")" ;

enum_type = "|"? enum_variant ( "|" enum_variant )* ;

primitive_type =
  | "bool"
  | "null"
  | "int"
  | "float"
  | "string"
  | IDENTIFIER ( "." IDENTIFIER )*
  ;

grouping_type = "(" type_expr ")" ;

type_param_list = "[" ( type_param ( "," type_param ","? )* )? "]" ;
type_param = IDENTIFIER ( ":" type_expr )? ( "=" type_expr ) ;
param_list = "(" ( param ( "," param ","? )* )? ")" ;
param = IDENTIFIER ( ":" type_expr )? ( "=" expr )? ;

constraint = "where" constraint_bound_list ;
constraint_bound_list = constraint_bound ( "," constraint_bound ","? )* ;
constraint_bound = IDENTIFIER ":" type_expr ;

expr_stmt = expr ;

expr =
  | do_block_expr
  | if_expr
  | match_expr
  | fn_expr
  | class_expr
  | enum_expr
  | spawn_expr
  | assignment_expr
  ;

do_block_expr = "do" block_stmt ;

if_expr = "if" condition if_expr_body ( "else" ( if_expr | block ) )? ;
if_expr_body =
  | block_stmt
  | ctrl_stmt
  ;

match_expr = "match" expr "{" match_case_list "}";
match_case_list = match_case ( separator match_case separator? )* ;
match_case = pattern case_guard? "=>" stmt ;

case_guard = "if" expr ;

pattern =
  | any_pattern
  | ignore_pattern
  | bool_pattern
  | null_pattern
  | integer_pattern
  | range_pattern
  | string_pattern
  | array_pattern
  | tuple_pattern
  | record_pattern
  | enum_pattern
  ;

rest_pattern =
  | ".." pattern_binding?
  | pattern
  ;

any_pattern = IDENTIFIER ;
ignore_pattern = "_" ;
bool_pattern = ( "true" | "false" ) pattern_binding? ;
null_pattern = "null" pattern_binding? ;
integer_pattern = integer pattern_binding? ;
range_pattern =
  ( | integer ".." integer
    | integer ".."
    | ".." integer
  ) pattern_binding? ;
string_pattern =
  | quote text quote
  | apos text apos
  ;
array_pattern = "[" rest_pattern ( "," rest_pattern ","? )* "]" ;
tuple_pattern = "(" rest_pattern ( "," rest_pattern ","? )* ")" ;
record_pattern = "{" record_pattern_item ( "," record_pattern_item ","? )* "}" ;
record_pattern_item =
  | IDENTIFIER
  | IDENTIFIER ":" pattern
  | rest_pattern
  ;
(* if matching on a result, `IDENTIFIER` must be `error` and it is not optional *)
enum_pattern = IDENTIFIER? "." IDENTIFIER ( tuple_pattern | record_pattern )? ;
pattern_binding = "as" IDENTIFIER ;

(* these exist only because they have different scoping rules. specifically,
   the name is not declared in the enclosing scope, only in its own body *)
fn_expr = fn ;
class_expr = class ;
enum_expr = enum ;

spawn_expr = "spawn" spawn_expr_body ;
spawn_expr_body =
  | block_stmt
  | call
  ;

assignment_expr = 
  | assignment_target ( assignment_op expression )?
  | pipeline_expr 
  ;
assignment_op = "=" | "+=" | "-=" | "/=" | "*=" | "%=" | "**=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "||=" | "&&=" | "??=" ;
assignment_target =
  | IDENTIFIER
  | call_expr field_access_expr
  | call_expr item_access_expr
  ;

(* `#` is allowed as an identifier in the context of a placeholder's right expression *)
pipeline_expr = logic_or_expr ( "|>" logic_or_expr )* ;
logic_or_expr = logic_and_expr ( "||" logic_and_expr )* ;
logic_and_expr = bitwise_or_expr ( "&&" bitwise_or_expr )* ;
bitwise_or_expr = bitwise_xor_expr ( "|" bitwise_xor_expr )* ;
bitwise_xor_expr = bitwise_and_expr ( "^" bitwise_and_expr )* ;
bitwise_and_expr = equality_expr ( "&" equality_expr )* ;
equality_expr = comparison_expr ( ( "==" | "!=" ) comparison_expr )* ;
comparison_expr = bitshift_expr ( ( ">" | ">=" | "<" | "<=" ) bitshift_expr )* ;
bitshift_expr = addition_expr ( ( "<<" | ">>" ) addition_expr )* ;
addition_expr = multiplication_expr ( ( "-" | "+" ) multiplication_expr )* ;
multiplication_expr = exponentiation_expr ( ("/" | "*" | "%" ) exponentiation_expr )* ;
exponentiation_expr = unary_expr ( "**" unary_expr )* ;

unary_expr = prefix_expr | inc_expr | dec_expr | postfix_expr ;
prefix_expr = ( "!" | "-" | "~" | "try" | "try!" ) unary_expr ;
inc_expr = "++" assignment_target | assignment_target "++" ;
dec_expr = "--" assignment_target | assignment_target "--" ;
postfix_expr = primary_expr ( call_expr | try_expr | field_access_expr | item_access_expr )* ;
call_expr = "(" args? ")" ;
try_expr = "." ( "try" | "try!" ) ;
postfix_match_expr = "." match_expr ;
field_access_expr = ( "." | "?." ) IDENTIFIER ;
item_access_expr = "[" expr "]" ;

primary_expr =
  | bool_expr
  | null_expr
  | number_expr
  | string_expr
  | range_expr
  | array_expr
  | record_expr
  | lambda_expr
  | tuple_expr
  | grouping_expr
  ;

bool_expr = "true" | "false" ;

null_expr = "null" ;

(*
valid numbers:
  0b0000_0000
  -149120421940
  0xb00ba
  -inf
  1.0e5
  3.14e-5
  1f
  1i
also with prefixes:
  10ms
  5.1s
integers have higher precedence than floats
*)
number_expr = ( integer | float ) IDENTIFIER? ;
integer = ( base_2 | base_10 | base_16 ) suffix? ;
integer_base_2 = regex{"0b[01]([01_]*[01])?"} ;
integer_base_10 = regex{"[0-9]([0-9_]*[0-9])?"} ;
integer_base_16 = regex{"0x[0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?"} ;
float =
  | "inf"
  | ( regex{"[0-9]+(\.[0-9]*)?([Ee][+-]?[0-9]+)?"} suffix? )
  ;
suffix = IDENTIFIER ;

(* strings also support escapes such as \n \t \x2800 etc.*)
string_expr =
  | ( quote string_fragment* quote ) suffix?
  | ( apos string_fragment* apos ) suffix?
  ;
string_fragment =
  | "{" expr "}"
  | "\{" text "}"
  | text
  ;
text = UTF8* ;
apos = "'" ;
quote = '"' ;

range_expr =
  (* exclusive end *)
  | expr ".." expr
  (* exclusive end, start=0 *)
  | ".." expr
  (* inclusive end *)
  | expr "..=" expr
  (* inclusive end, start=0 *)
  | "..=" expr
  (* full *)
  | ".."
  | expr
  ;

array_expr = "[" ( array_item_list | array_len_init ) "]" ;
array_item_list = spread_expr ( "," spread_expr ","? )* ;
array_len_init = expr ";" expr ;

record_expr = "{" record_fields "}" ;
record_field_list = record_field ( "," record_field ","? )* ;
record_field =
  | IDENTIFIER
  | IDENTIFIER ":" expr
  | "[" expr "]" ":" expr
  | spread_expr
  ;

lambda_expr = "\\" lambda_param_list block_stmt ;
lambda_param_list = IDENTIFIER | param_list ;

(*
  0 elements  -> no comma
  1 element   -> ends with comma
  >1 elements -> separated by comma + optional trailing comma

() // tuple
(a) // group
(a,) // tuple
(a,b) // tuple
*)
tuple_expr = "(" ( tuple_expr_single | tuple_expr_multi ) ")" ;
tuple_expr_single = ( expr "," )? ;
tuple_expr_multi = ( expr "," )+ expr? ;

grouping_expr = "(" expr ")" ;

spread_expr = "..."? expr ;

separator = "," | ";" | NEWLINE ;

IDENTIFIER = regex{"[a-bA-B_][a-bA-B_0-9]*"} ;

NEWLINE = regex{"\n"} ;

COMMENT = regex{"\/\/[^\n]*"}

// Multiline comments can be nested.
MULTI_LINE_COMMENT = "/*" ( MULTI_LINE_COMMENT | regex{"(?:(?!\*\/).)+"} ) "*/"
